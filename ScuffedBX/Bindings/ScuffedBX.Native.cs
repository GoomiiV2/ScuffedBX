// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace ScuffedBX
{
    public unsafe partial class Vector2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float X;
            internal float Y;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector2@ScuffedBX@@QEAA@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector2@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector2> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector2>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Vector2 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Vector2 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vector2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vector2(native.ToPointer(), skipVTables);
        }

        internal static Vector2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vector2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vector2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vector2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vector2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vector2(float x, float y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, x, y);
        }

        public Vector2(global::ScuffedBX.Vector2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Vector2.__Internal*) __Instance) = *((global::ScuffedBX.Vector2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public static implicit operator System.Numerics.Vector2(Vector2 vec) => new System.Numerics.Vector2(vec.X, vec.Y);
        public static implicit operator Vector2(System.Numerics.Vector2 vec) => new Vector2(vec.X, vec.Y);
    }

    public unsafe partial class Vector3 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float X;
            internal float Y;
            internal float Z;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector3@ScuffedBX@@QEAA@MMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector3@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector3> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector3>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Vector3 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Vector3 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vector3 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vector3(native.ToPointer(), skipVTables);
        }

        internal static Vector3 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vector3)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vector3 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vector3(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector3(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vector3(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vector3(float x, float y, float z)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, x, y, z);
        }

        public Vector3(global::ScuffedBX.Vector3 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector3.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Vector3.__Internal*) __Instance) = *((global::ScuffedBX.Vector3.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->Z;
            }

            set
            {
                ((__Internal*)__Instance)->Z = value;
            }
        }

        public static implicit operator System.Numerics.Vector3(Vector3 vec) => new System.Numerics.Vector3(vec.X, vec.Y, vec.Z);
        public static implicit operator Vector3(System.Numerics.Vector3 vec) => new Vector3(vec.X, vec.Y, vec.Z);
    }

    public unsafe partial class Vector4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float X;
            internal float Y;
            internal float Z;
            internal float W;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector4@ScuffedBX@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float x, float y, float z, float w);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Vector4@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector4> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Vector4>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Vector4 managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Vector4 managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vector4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vector4(native.ToPointer(), skipVTables);
        }

        internal static Vector4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vector4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vector4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vector4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vector4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vector4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vector4(float x, float y, float z, float w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, x, y, z, w);
        }

        public Vector4(global::ScuffedBX.Vector4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Vector4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Vector4.__Internal*) __Instance) = *((global::ScuffedBX.Vector4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->Z;
            }

            set
            {
                ((__Internal*)__Instance)->Z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->W;
            }

            set
            {
                ((__Internal*)__Instance)->W = value;
            }
        }

        public static implicit operator System.Numerics.Vector4(Vector4 vec) => new System.Numerics.Vector4(vec.X, vec.Y, vec.Z, vec.W);
        public static implicit operator Vector4(System.Numerics.Vector4 vec) => new Vector4(vec.X, vec.Y, vec.Z, vec.W);
        public static implicit operator System.Numerics.Quaternion(Vector4 vec) => new System.Numerics.Quaternion(vec.X, vec.Y, vec.Z, vec.W);
        public static implicit operator Vector4(System.Numerics.Quaternion vec) => new Vector4(vec.X, vec.Y, vec.Z, vec.W);
    }

    public unsafe partial class ColorRGBA : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float R;
            internal float G;
            internal float B;
            internal float A;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0ColorRGBA@ScuffedBX@@QEAA@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, uint color);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0ColorRGBA@ScuffedBX@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0ColorRGBA@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.ColorRGBA> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.ColorRGBA>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.ColorRGBA managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.ColorRGBA managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ColorRGBA __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ColorRGBA(native.ToPointer(), skipVTables);
        }

        internal static ColorRGBA __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ColorRGBA)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ColorRGBA __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ColorRGBA(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ColorRGBA(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ColorRGBA(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ColorRGBA(uint color)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.ColorRGBA.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, color);
        }

        public ColorRGBA(float r, float g, float b, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.ColorRGBA.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, r, g, b, a);
        }

        public ColorRGBA(global::ScuffedBX.ColorRGBA _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.ColorRGBA.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.ColorRGBA.__Internal*) __Instance) = *((global::ScuffedBX.ColorRGBA.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator global::ScuffedBX.ColorRGBA(uint color)
        {
            return new global::ScuffedBX.ColorRGBA(color);
        }

        public float R
        {
            get
            {
                return ((__Internal*)__Instance)->R;
            }

            set
            {
                ((__Internal*)__Instance)->R = value;
            }
        }

        public float G
        {
            get
            {
                return ((__Internal*)__Instance)->G;
            }

            set
            {
                ((__Internal*)__Instance)->G = value;
            }
        }

        public float B
        {
            get
            {
                return ((__Internal*)__Instance)->B;
            }

            set
            {
                ((__Internal*)__Instance)->B = value;
            }
        }

        public float A
        {
            get
            {
                return ((__Internal*)__Instance)->A;
            }

            set
            {
                ((__Internal*)__Instance)->A = value;
            }
        }

    }

    public unsafe partial class Bone : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1068)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal global::ScuffedBX.Vector3.__Internal Position;
            internal global::ScuffedBX.Vector4.__Internal Rotation;
            internal global::ScuffedBX.Vector3.__Internal Scale;
            internal int ParentIdx;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Bone@ScuffedBX@@QEAA@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int parentIdx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Bone@ScuffedBX@@QEAA@PEBDHUVector3@1@UVector4@1@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int parentIdx, __IntPtr pos, __IntPtr rot, __IntPtr scale);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Bone@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?SetName@Bone@ScuffedBX@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Bone> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Bone>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Bone managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Bone managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Bone __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Bone(native.ToPointer(), skipVTables);
        }

        internal static Bone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Bone)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Bone __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Bone(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Bone(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Bone(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Bone(string name, int parentIdx)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Bone.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, name, parentIdx);
        }

        public Bone(string name, int parentIdx, global::ScuffedBX.Vector3 pos, global::ScuffedBX.Vector4 rot, global::ScuffedBX.Vector3 scale)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Bone.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg2 = pos.__Instance;
            if (ReferenceEquals(rot, null))
                throw new global::System.ArgumentNullException("rot", "Cannot be null because it is passed by value.");
            var __arg3 = rot.__Instance;
            if (ReferenceEquals(scale, null))
                throw new global::System.ArgumentNullException("scale", "Cannot be null because it is passed by value.");
            var __arg4 = scale.__Instance;
            __Internal.ctor(__Instance, name, parentIdx, __arg2, __arg3, __arg4);
        }

        public Bone(global::ScuffedBX.Bone _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Bone.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Bone.__Internal*) __Instance) = *((global::ScuffedBX.Bone.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetName(string name)
        {
            __Internal.SetName(__Instance, name);
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::ScuffedBX.Vector3 Position
        {
            get
            {
                return global::ScuffedBX.Vector3.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Position = *(global::ScuffedBX.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::ScuffedBX.Vector4 Rotation
        {
            get
            {
                return global::ScuffedBX.Vector4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Rotation));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Rotation = *(global::ScuffedBX.Vector4.__Internal*) value.__Instance;
            }
        }

        public global::ScuffedBX.Vector3 Scale
        {
            get
            {
                return global::ScuffedBX.Vector3.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Scale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Scale = *(global::ScuffedBX.Vector3.__Internal*) value.__Instance;
            }
        }

        public int ParentIdx
        {
            get
            {
                return ((__Internal*)__Instance)->ParentIdx;
            }

            set
            {
                ((__Internal*)__Instance)->ParentIdx = value;
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
    }

    public unsafe partial class Skeleton : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1032)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal __IntPtr Bones;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Skeleton@ScuffedBX@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Skeleton@ScuffedBX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??1Skeleton@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?SetName@Skeleton@ScuffedBX@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddBone@Skeleton@ScuffedBX@@QEAAXUBone@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBone(__IntPtr __instance, __IntPtr bone);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetBone@Skeleton@ScuffedBX@@QEAAPEAUBone@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetBone(__IntPtr __instance, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumBones@Skeleton@ScuffedBX@@QEAA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumBones(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Skeleton> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Skeleton>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Skeleton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Skeleton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Skeleton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Skeleton(native.ToPointer(), skipVTables);
        }

        internal static Skeleton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Skeleton)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Skeleton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Skeleton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Skeleton(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Skeleton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Skeleton(string name)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Skeleton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, name);
        }

        public Skeleton(global::ScuffedBX.Skeleton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Skeleton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Skeleton.__Internal*) __Instance) = *((global::ScuffedBX.Skeleton.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetName(string name)
        {
            __Internal.SetName(__Instance, name);
        }

        public void AddBone(global::ScuffedBX.Bone bone)
        {
            if (ReferenceEquals(bone, null))
                throw new global::System.ArgumentNullException("bone", "Cannot be null because it is passed by value.");
            var __arg0 = bone.__Instance;
            __Internal.AddBone(__Instance, __arg0);
        }

        public global::ScuffedBX.Bone GetBone(int idx)
        {
            var ___ret = __Internal.GetBone(__Instance, idx);
            var __result0 = global::ScuffedBX.Bone.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static implicit operator global::ScuffedBX.Skeleton(string name)
        {
            return new global::ScuffedBX.Skeleton(name);
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public __IntPtr Bones
        {
            get
            {
                return ((__Internal*)__Instance)->Bones;
            }

            set
            {
                ((__Internal*)__Instance)->Bones = (__IntPtr) value;
            }
        }

        public int NumBones
        {
            get
            {
                var ___ret = __Internal.GetNumBones(__Instance);
                return ___ret;
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
    }

    public unsafe partial class MatSection : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1036)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal uint MatIdx;
            internal uint Offset;
            internal uint Len;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0MatSection@ScuffedBX@@QEAA@III@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, uint matIdx, uint offset, uint len);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0MatSection@ScuffedBX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.MatSection> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.MatSection>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.MatSection managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.MatSection managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MatSection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MatSection(native.ToPointer(), skipVTables);
        }

        internal static MatSection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MatSection)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MatSection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MatSection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MatSection(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MatSection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MatSection(uint matIdx, uint offset, uint len)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.MatSection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, matIdx, offset, len);
        }

        public MatSection(global::ScuffedBX.MatSection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.MatSection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.MatSection.__Internal*) __Instance) = *((global::ScuffedBX.MatSection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public uint MatIdx
        {
            get
            {
                return ((__Internal*)__Instance)->MatIdx;
            }

            set
            {
                ((__Internal*)__Instance)->MatIdx = value;
            }
        }

        public uint Offset
        {
            get
            {
                return ((__Internal*)__Instance)->Offset;
            }

            set
            {
                ((__Internal*)__Instance)->Offset = value;
            }
        }

        public uint Len
        {
            get
            {
                return ((__Internal*)__Instance)->Len;
            }

            set
            {
                ((__Internal*)__Instance)->Len = value;
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
    }

    public unsafe partial class MatInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2048)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal fixed sbyte DiffusePath[1024];

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0MatInfo@ScuffedBX@@QEAA@PEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string diffusePath);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0MatInfo@ScuffedBX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.MatInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.MatInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.MatInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.MatInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MatInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MatInfo(native.ToPointer(), skipVTables);
        }

        internal static MatInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MatInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MatInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MatInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MatInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MatInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MatInfo(string name, string diffusePath)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.MatInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, name, diffusePath);
        }

        public MatInfo(global::ScuffedBX.MatInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.MatInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.MatInfo.__Internal*) __Instance) = *((global::ScuffedBX.MatInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public sbyte[] DiffusePath
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->DiffusePath, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->DiffusePath[i] = value[i];
                }
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
        public string DiffusePathStr => Utils.GimmeTheDammString(DiffusePath);
    }

    public unsafe partial class BoneWeight : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int BoneIdx;
            internal float Weight;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0BoneWeight@ScuffedBX@@QEAA@HM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, int boneIdx, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0BoneWeight@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.BoneWeight> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.BoneWeight>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.BoneWeight managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.BoneWeight managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BoneWeight __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BoneWeight(native.ToPointer(), skipVTables);
        }

        internal static BoneWeight __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BoneWeight)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BoneWeight __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BoneWeight(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BoneWeight(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BoneWeight(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BoneWeight(int boneIdx, float weight)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.BoneWeight.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance, boneIdx, weight);
        }

        public BoneWeight(global::ScuffedBX.BoneWeight _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.BoneWeight.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.BoneWeight.__Internal*) __Instance) = *((global::ScuffedBX.BoneWeight.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int BoneIdx
        {
            get
            {
                return ((__Internal*)__Instance)->BoneIdx;
            }

            set
            {
                ((__Internal*)__Instance)->BoneIdx = value;
            }
        }

        public float Weight
        {
            get
            {
                return ((__Internal*)__Instance)->Weight;
            }

            set
            {
                ((__Internal*)__Instance)->Weight = value;
            }
        }

    }

    public unsafe partial class Model : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1136)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal global::ScuffedBX.Vector3.__Internal Position;
            internal global::ScuffedBX.Vector4.__Internal Rotation;
            internal global::ScuffedBX.Vector3.__Internal Scale;
            internal int SkeletonIdx;
            internal int NumBonesPerVert;
            internal __IntPtr Positions;
            internal __IntPtr Normals;
            internal __IntPtr Tangents;
            internal __IntPtr UVs0;
            internal __IntPtr Colors;
            internal __IntPtr Indices;
            internal __IntPtr MatSections;
            internal __IntPtr BoneWeights;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Model@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Model@ScuffedBX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??1Model@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?SetName@Model@ScuffedBX@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddVert@Model@ScuffedBX@@QEAA?BHPEAUVector3@2@0PEAUVector4@2@PEAUVector2@2@PEAUColorRGBA@2@QEAUBoneWeight@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddVert(__IntPtr __instance, __IntPtr pos, __IntPtr normal, __IntPtr tangent, __IntPtr uv0, __IntPtr color, global::ScuffedBX.BoneWeight.__Internal[] boneWeights);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddIndice@Model@ScuffedBX@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddIndice(__IntPtr __instance, uint indice);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddIndices@Model@ScuffedBX@@QEAAXPEBIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddIndices(__IntPtr __instance, uint* indices, int numIndices);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddTri@Model@ScuffedBX@@QEAAXIII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddTri(__IntPtr __instance, uint i1, uint i2, uint i3);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?SetIndices@Model@ScuffedBX@@QEAAXQEAIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetIndices(__IntPtr __instance, uint[] indices, int len);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddMatSection@Model@ScuffedBX@@QEAAXVMatSection@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddMatSection(__IntPtr __instance, __IntPtr matSection);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetMatSection@Model@ScuffedBX@@QEAAPEAVMatSection@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetMatSection(__IntPtr __instance, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetPosition@Model@ScuffedBX@@QEAA?BUVector3@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetPosition(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNormal@Model@ScuffedBX@@QEAA?BUVector3@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetNormal(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetTangent@Model@ScuffedBX@@QEAA?BUVector4@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetTangent(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetUVs0@Model@ScuffedBX@@QEAA?BUVector2@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetUVs0(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetColor@Model@ScuffedBX@@QEAA?BUColorRGBA@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetColor(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetIndice@Model@ScuffedBX@@QEAA?BII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetIndice(__IntPtr __instance, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetIndices@Model@ScuffedBX@@QEAAPEBII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetIndices(__IntPtr __instance, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetBoneWeight@Model@ScuffedBX@@QEAA?BUBoneWeight@2@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetBoneWeight(__IntPtr __instance, __IntPtr @return, uint idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddBoneWeight@Model@ScuffedBX@@QEAAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBoneWeight(__IntPtr __instance, int boneIdx, float weight);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddBoneWeights@Model@ScuffedBX@@QEAAXQEAHQEAM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBoneWeights(__IntPtr __instance, int[] boneIdxs, float[] weights);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumVerts@Model@ScuffedBX@@QEAA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumVerts(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumMatSections@Model@ScuffedBX@@QEAA?BIXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetNumMatSections(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumIndices@Model@ScuffedBX@@QEAA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumIndices(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?HasNormals@Model@ScuffedBX@@QEAA?B_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasNormals(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?HasTangents@Model@ScuffedBX@@QEAA?B_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasTangents(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?HasUvs0@Model@ScuffedBX@@QEAA?B_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasUvs0(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?HasColors@Model@ScuffedBX@@QEAA?B_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasColors(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Model> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Model>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Model managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Model managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Model __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Model(native.ToPointer(), skipVTables);
        }

        internal static Model __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Model)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Model __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Model(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Model(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Model(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Model()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Model.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Model(global::ScuffedBX.Model _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Model.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Model.__Internal*) __Instance) = *((global::ScuffedBX.Model.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetName(string name)
        {
            __Internal.SetName(__Instance, name);
        }

        public int AddVert(global::ScuffedBX.Vector3 pos, global::ScuffedBX.Vector3 normal, global::ScuffedBX.Vector4 tangent, global::ScuffedBX.Vector2 uv0, global::ScuffedBX.ColorRGBA color, global::ScuffedBX.BoneWeight[] boneWeights)
        {
            var __arg0 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var __arg1 = normal is null ? __IntPtr.Zero : normal.__Instance;
            var __arg2 = tangent is null ? __IntPtr.Zero : tangent.__Instance;
            var __arg3 = uv0 is null ? __IntPtr.Zero : uv0.__Instance;
            var __arg4 = color is null ? __IntPtr.Zero : color.__Instance;
            global::ScuffedBX.BoneWeight.__Internal[] __boneWeights;
            if (boneWeights == null)
                __boneWeights = null;
            else
            {
                __boneWeights = new global::ScuffedBX.BoneWeight.__Internal[boneWeights.Length];
                for (int i = 0; i < __boneWeights.Length; i++)
                {
                    var __element = boneWeights[i];
                    __boneWeights[i] = __element is null ? new global::ScuffedBX.BoneWeight.__Internal() : *(global::ScuffedBX.BoneWeight.__Internal*) __element.__Instance;
                }
            }
            var __arg5 = __boneWeights;
            var ___ret = __Internal.AddVert(__Instance, __arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
            return ___ret;
        }

        public void AddIndice(uint indice)
        {
            __Internal.AddIndice(__Instance, indice);
        }

        public void AddIndices(ref uint indices, int numIndices)
        {
            fixed (uint* __indices0 = &indices)
            {
                var __arg0 = __indices0;
                __Internal.AddIndices(__Instance, __arg0, numIndices);
            }
        }

        public void AddTri(uint i1, uint i2, uint i3)
        {
            __Internal.AddTri(__Instance, i1, i2, i3);
        }

        public void SetIndices(uint[] indices, int len)
        {
            __Internal.SetIndices(__Instance, indices, len);
        }

        public void AddMatSection(global::ScuffedBX.MatSection matSection)
        {
            if (ReferenceEquals(matSection, null))
                throw new global::System.ArgumentNullException("matSection", "Cannot be null because it is passed by value.");
            var __arg0 = matSection.__Instance;
            __Internal.AddMatSection(__Instance, __arg0);
        }

        public global::ScuffedBX.MatSection GetMatSection(uint idx)
        {
            var ___ret = __Internal.GetMatSection(__Instance, idx);
            var __result0 = global::ScuffedBX.MatSection.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public global::ScuffedBX.Vector3 GetPosition(uint idx)
        {
            var ___ret = new global::ScuffedBX.Vector3.__Internal();
            __Internal.GetPosition(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.Vector3.__CreateInstance(___ret);
        }

        public global::ScuffedBX.Vector3 GetNormal(uint idx)
        {
            var ___ret = new global::ScuffedBX.Vector3.__Internal();
            __Internal.GetNormal(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.Vector3.__CreateInstance(___ret);
        }

        public global::ScuffedBX.Vector4 GetTangent(uint idx)
        {
            var ___ret = new global::ScuffedBX.Vector4.__Internal();
            __Internal.GetTangent(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.Vector4.__CreateInstance(___ret);
        }

        public global::ScuffedBX.Vector2 GetUVs0(uint idx)
        {
            var ___ret = new global::ScuffedBX.Vector2.__Internal();
            __Internal.GetUVs0(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.Vector2.__CreateInstance(___ret);
        }

        public global::ScuffedBX.ColorRGBA GetColor(uint idx)
        {
            var ___ret = new global::ScuffedBX.ColorRGBA.__Internal();
            __Internal.GetColor(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.ColorRGBA.__CreateInstance(___ret);
        }

        public uint GetIndice(uint idx)
        {
            var ___ret = __Internal.GetIndice(__Instance, idx);
            return ___ret;
        }

        public uint* GetIndices(uint idx)
        {
            var ___ret = __Internal.GetIndices(__Instance, idx);
            return ___ret;
        }

        public global::ScuffedBX.BoneWeight GetBoneWeight(uint idx)
        {
            var ___ret = new global::ScuffedBX.BoneWeight.__Internal();
            __Internal.GetBoneWeight(__Instance, new IntPtr(&___ret), idx);
            return global::ScuffedBX.BoneWeight.__CreateInstance(___ret);
        }

        public void AddBoneWeight(int boneIdx, float weight)
        {
            __Internal.AddBoneWeight(__Instance, boneIdx, weight);
        }

        public void AddBoneWeights(int[] boneIdxs, float[] weights)
        {
            __Internal.AddBoneWeights(__Instance, boneIdxs, weights);
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::ScuffedBX.Vector3 Position
        {
            get
            {
                return global::ScuffedBX.Vector3.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Position = *(global::ScuffedBX.Vector3.__Internal*) value.__Instance;
            }
        }

        public global::ScuffedBX.Vector4 Rotation
        {
            get
            {
                return global::ScuffedBX.Vector4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Rotation));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Rotation = *(global::ScuffedBX.Vector4.__Internal*) value.__Instance;
            }
        }

        public global::ScuffedBX.Vector3 Scale
        {
            get
            {
                return global::ScuffedBX.Vector3.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Scale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Scale = *(global::ScuffedBX.Vector3.__Internal*) value.__Instance;
            }
        }

        public int SkeletonIdx
        {
            get
            {
                return ((__Internal*)__Instance)->SkeletonIdx;
            }

            set
            {
                ((__Internal*)__Instance)->SkeletonIdx = value;
            }
        }

        public int NumBonesPerVert
        {
            get
            {
                return ((__Internal*)__Instance)->NumBonesPerVert;
            }

            set
            {
                ((__Internal*)__Instance)->NumBonesPerVert = value;
            }
        }

        public __IntPtr Positions
        {
            get
            {
                return ((__Internal*)__Instance)->Positions;
            }

            set
            {
                ((__Internal*)__Instance)->Positions = (__IntPtr) value;
            }
        }

        public __IntPtr Normals
        {
            get
            {
                return ((__Internal*)__Instance)->Normals;
            }

            set
            {
                ((__Internal*)__Instance)->Normals = (__IntPtr) value;
            }
        }

        public __IntPtr Tangents
        {
            get
            {
                return ((__Internal*)__Instance)->Tangents;
            }

            set
            {
                ((__Internal*)__Instance)->Tangents = (__IntPtr) value;
            }
        }

        public __IntPtr UVs0
        {
            get
            {
                return ((__Internal*)__Instance)->UVs0;
            }

            set
            {
                ((__Internal*)__Instance)->UVs0 = (__IntPtr) value;
            }
        }

        public __IntPtr Colors
        {
            get
            {
                return ((__Internal*)__Instance)->Colors;
            }

            set
            {
                ((__Internal*)__Instance)->Colors = (__IntPtr) value;
            }
        }

        public __IntPtr Indices
        {
            get
            {
                return ((__Internal*)__Instance)->Indices;
            }

            set
            {
                ((__Internal*)__Instance)->Indices = (__IntPtr) value;
            }
        }

        public __IntPtr MatSections
        {
            get
            {
                return ((__Internal*)__Instance)->MatSections;
            }

            set
            {
                ((__Internal*)__Instance)->MatSections = (__IntPtr) value;
            }
        }

        public __IntPtr BoneWeights
        {
            get
            {
                return ((__Internal*)__Instance)->BoneWeights;
            }

            set
            {
                ((__Internal*)__Instance)->BoneWeights = (__IntPtr) value;
            }
        }

        public int NumVerts
        {
            get
            {
                var ___ret = __Internal.GetNumVerts(__Instance);
                return ___ret;
            }
        }

        public uint NumMatSections
        {
            get
            {
                var ___ret = __Internal.GetNumMatSections(__Instance);
                return ___ret;
            }
        }

        public int NumIndices
        {
            get
            {
                var ___ret = __Internal.GetNumIndices(__Instance);
                return ___ret;
            }
        }

        public bool HasNormals
        {
            get
            {
                var ___ret = __Internal.HasNormals(__Instance);
                return ___ret;
            }
        }

        public bool HasTangents
        {
            get
            {
                var ___ret = __Internal.HasTangents(__Instance);
                return ___ret;
            }
        }

        public bool HasUvs0
        {
            get
            {
                var ___ret = __Internal.HasUvs0(__Instance);
                return ___ret;
            }
        }

        public bool HasColors
        {
            get
            {
                var ___ret = __Internal.HasColors(__Instance);
                return ___ret;
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
    }

    public unsafe partial class Scene : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1056)]
        public partial struct __Internal
        {
            internal fixed sbyte Name[1024];
            internal __IntPtr Models;
            internal __IntPtr Materials;
            internal __IntPtr Skeletons;
            internal double UnitScale;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Scene@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0Scene@ScuffedBX@@QEAA@AEBV01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??1Scene@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?SetName@Scene@ScuffedBX@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetName(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetModel@Scene@ScuffedBX@@QEAAPEAVModel@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetModel(__IntPtr __instance, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddModel@Scene@ScuffedBX@@QEAAXPEAVModel@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddModel(__IntPtr __instance, __IntPtr model);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetMatInfo@Scene@ScuffedBX@@QEAAPEAVMatInfo@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetMatInfo(__IntPtr __instance, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddMatInfo@Scene@ScuffedBX@@QEAAIVMatInfo@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint AddMatInfo(__IntPtr __instance, __IntPtr matInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetSkeleton@Scene@ScuffedBX@@QEAAPEAVSkeleton@2@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetSkeleton(__IntPtr __instance, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?AddSkeleton@Scene@ScuffedBX@@QEAAHPEAVSkeleton@2@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddSkeleton(__IntPtr __instance, __IntPtr skeleton);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumModels@Scene@ScuffedBX@@QEBA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumModels(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumMatInfos@Scene@ScuffedBX@@QEBA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumMatInfos(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?GetNumSkeletons@Scene@ScuffedBX@@QEAA?BHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumSkeletons(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Scene> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.Scene>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.Scene managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.Scene managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Scene __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Scene(native.ToPointer(), skipVTables);
        }

        internal static Scene __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Scene)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Scene __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Scene(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Scene(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Scene(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Scene()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Scene.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public Scene(global::ScuffedBX.Scene _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.Scene.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.Scene.__Internal*) __Instance) = *((global::ScuffedBX.Scene.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (callNativeDtor)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void SetName(string name)
        {
            __Internal.SetName(__Instance, name);
        }

        public global::ScuffedBX.Model GetModel(int idx)
        {
            var ___ret = __Internal.GetModel(__Instance, idx);
            var __result0 = global::ScuffedBX.Model.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public void AddModel(global::ScuffedBX.Model model)
        {
            var __arg0 = model is null ? __IntPtr.Zero : model.__Instance;
            __Internal.AddModel(__Instance, __arg0);
        }

        public global::ScuffedBX.MatInfo GetMatInfo(int idx)
        {
            var ___ret = __Internal.GetMatInfo(__Instance, idx);
            var __result0 = global::ScuffedBX.MatInfo.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public uint AddMatInfo(global::ScuffedBX.MatInfo matInfo)
        {
            if (ReferenceEquals(matInfo, null))
                throw new global::System.ArgumentNullException("matInfo", "Cannot be null because it is passed by value.");
            var __arg0 = matInfo.__Instance;
            var ___ret = __Internal.AddMatInfo(__Instance, __arg0);
            return ___ret;
        }

        public global::ScuffedBX.Skeleton GetSkeleton(int idx)
        {
            var ___ret = __Internal.GetSkeleton(__Instance, idx);
            var __result0 = global::ScuffedBX.Skeleton.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public int AddSkeleton(global::ScuffedBX.Skeleton skeleton)
        {
            var __arg0 = skeleton is null ? __IntPtr.Zero : skeleton.__Instance;
            var ___ret = __Internal.AddSkeleton(__Instance, __arg0);
            return ___ret;
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 1024);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1024; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public __IntPtr Models
        {
            get
            {
                return ((__Internal*)__Instance)->Models;
            }

            set
            {
                ((__Internal*)__Instance)->Models = (__IntPtr) value;
            }
        }

        public __IntPtr Materials
        {
            get
            {
                return ((__Internal*)__Instance)->Materials;
            }

            set
            {
                ((__Internal*)__Instance)->Materials = (__IntPtr) value;
            }
        }

        public __IntPtr Skeletons
        {
            get
            {
                return ((__Internal*)__Instance)->Skeletons;
            }

            set
            {
                ((__Internal*)__Instance)->Skeletons = (__IntPtr) value;
            }
        }

        public double UnitScale
        {
            get
            {
                return ((__Internal*)__Instance)->UnitScale;
            }

            set
            {
                ((__Internal*)__Instance)->UnitScale = value;
            }
        }

        public int NumModels
        {
            get
            {
                var ___ret = __Internal.GetNumModels(__Instance);
                return ___ret;
            }
        }

        public int NumMatInfos
        {
            get
            {
                var ___ret = __Internal.GetNumMatInfos(__Instance);
                return ___ret;
            }
        }

        public int NumSkeletons
        {
            get
            {
                var ___ret = __Internal.GetNumSkeletons(__Instance);
                return ___ret;
            }
        }

        public string NameStr => Utils.GimmeTheDammString(Name);
    }

    public unsafe partial class FBXSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal byte EmbedResources;
            internal byte ExportAsBinary;

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0FBXSettings@ScuffedBX@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "??0FBXSettings@ScuffedBX@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.FBXSettings> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ScuffedBX.FBXSettings>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ScuffedBX.FBXSettings managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ScuffedBX.FBXSettings managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FBXSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FBXSettings(native.ToPointer(), skipVTables);
        }

        internal static FBXSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FBXSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FBXSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FBXSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FBXSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FBXSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FBXSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.FBXSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            __Internal.ctor(__Instance);
        }

        public FBXSettings(global::ScuffedBX.FBXSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ScuffedBX.FBXSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ScuffedBX.FBXSettings.__Internal*) __Instance) = *((global::ScuffedBX.FBXSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool EmbedResources
        {
            get
            {
                return ((__Internal*)__Instance)->EmbedResources != 0;
            }

            set
            {
                ((__Internal*)__Instance)->EmbedResources = (byte) (value ? 1 : 0);
            }
        }

        public bool ExportAsBinary
        {
            get
            {
                return ((__Internal*)__Instance)->ExportAsBinary != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ExportAsBinary = (byte) (value ? 1 : 0);
            }
        }

    }

    public unsafe partial class ScuffedBX
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?ExportAsFBX@ScuffedBX@@YAXVScene@1@PEBDUFBXSettings@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ExportAsFBX(__IntPtr scene, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath, global::ScuffedBX.FBXSettings.__Internal settings);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?ImportFromFBX@ScuffedBX@@YAPEAVScene@1@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFromFBX([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?PrintFBXInfo@ScuffedBX@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrintFBXInfo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filePath);

            [SuppressUnmanagedCodeSecurity, DllImport("ScuffedBX.Native.dll", EntryPoint = "?PrintScene@ScuffedBX@@YAXVScene@1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrintScene(__IntPtr scene);
        }

        public static void ExportAsFBX(global::ScuffedBX.Scene scene, string filePath, global::ScuffedBX.FBXSettings settings)
        {
            if (ReferenceEquals(scene, null))
                throw new global::System.ArgumentNullException("scene", "Cannot be null because it is passed by value.");
            var __arg0 = scene.__Instance;
            if (ReferenceEquals(settings, null))
                throw new global::System.ArgumentNullException("settings", "Cannot be null because it is passed by value.");
            var __arg2 = settings.__Instance;
            __Internal.ExportAsFBX(__arg0, filePath, *(global::ScuffedBX.FBXSettings.__Internal*) __arg2);
        }

        public static global::ScuffedBX.Scene ImportFromFBX(string filePath)
        {
            var ___ret = __Internal.ImportFromFBX(filePath);
            var __result0 = global::ScuffedBX.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static void PrintFBXInfo(string filePath)
        {
            __Internal.PrintFBXInfo(filePath);
        }

        public static void PrintScene(global::ScuffedBX.Scene scene)
        {
            if (ReferenceEquals(scene, null))
                throw new global::System.ArgumentNullException("scene", "Cannot be null because it is passed by value.");
            var __arg0 = scene.__Instance;
            __Internal.PrintScene(__arg0);
        }
    }
}
